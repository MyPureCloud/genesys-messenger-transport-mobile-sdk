#!/usr/bin/env kotlin
@file:DependsOn("com.github.ajalt.clikt:clikt-jvm:3.1.0")
@file:DependsOn("com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.12.2")
@file:DependsOn("com.fasterxml.jackson.module:jackson-module-kotlin:2.12.2")
@file:CompilerOptions("-jvm-target", "1.8")

import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import com.fasterxml.jackson.module.kotlin.readValue
import com.fasterxml.jackson.module.kotlin.registerKotlinModule
import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.types.file
import java.io.File
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.time.ZonedDateTime

class GenerateRegionCommand : CliktCommand(
    help = """
        Generate the Region enum using service-discovery data.
        
        It will clone the service-discovery git repo from BitBucket and use its service-environment.yml to generate correct regions.
    """.trimIndent()
) {

    private val cloneInto: File by option(help = """
        Clone service-discovery git repo here. By default, it will use a temp folder.
        """.trimIndent())
        .file(
            canBeFile = false,
            canBeDir = true,
            mustExist = true,
            mustBeWritable = true
        )
        .default(
            Files.createTempDirectory("generate-region")
                .toFile()
                .also { deleteCloneInto = true }
        )
    private val output: File by option(help = """
        Where to write out the generated source. By default it will write out to the appropriate file.
    """.trimIndent())
        .file(
            canBeFile = true,
            canBeDir = false,
            mustExist = false,
            mustBeWritable = true
        )
        .default(
            Paths.get("")
                .toAbsolutePath()
                .resolve("transport", "src","commonMain", "kotlin", "com", "genesys", "cloud", "messenger", "transport", "Region.kt")
                .toFile()
        )
    private var deleteCloneInto = false

    override fun run() {
        try {
            cloneGitRepo()
            val serviceEnvironments = loadServiceEnvironments()
            val regionCode = generateRegionCode(serviceEnvironments)
            echo(regionCode)
            output.writeText(regionCode)
        } finally {
            if (deleteCloneInto) {
                cloneInto.deleteRecursively()
            }
        }
    }

    private fun cloneGitRepo() {
        val clone = ProcessBuilder()
            .directory(cloneInto)
            .command("git", "clone", "--depth", "1", "git@bitbucket.org:inindca/service-discovery.git")
            .redirectInput(ProcessBuilder.Redirect.INHERIT)
            .redirectOutput(ProcessBuilder.Redirect.INHERIT)
            .redirectError(ProcessBuilder.Redirect.INHERIT)
            .start()
        check(clone.waitFor() == 0) { "Failed to clone" }
    }

    private fun loadServiceEnvironments(): List<ServiceEnvironment> {
        val serviceEnvironmentFile = cloneInto
            .resolve("service-discovery")
            .resolve("service-environment.yml")
            .also { check(it.exists()) { "Missing ${cloneInto.toPath().relativize(it.toPath())}" } }
        val allServiceEnvironments: List<ServiceEnvironment> = ObjectMapper(YAMLFactory())
            .registerKotlinModule()
            .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
            .readValue(serviceEnvironmentFile)
        val bannedKeywords = listOf("dev", "test", "mock")
        return allServiceEnvironments
            .filterNot { serviceEnvironment -> bannedKeywords.any { serviceEnvironment.name.contains(it) } }
    }

    private fun generateRegionCode(serviceEnvironments: List<ServiceEnvironment>) = """
        package com.genesys.cloud.messenger.transport
        
        // Generated by: generate-region.main.kts
        // Generated at: ${ZonedDateTime.now()}
        
        enum class Region(
            val domain: String
        ) {
            ${serviceEnvironments.joinToString(separator = ",\n${" ".repeat(12)}") { generateRegionObjectCode(it) }}
        }

    """.trimIndent()

    private fun generateRegionObjectCode(serviceEnvironment: ServiceEnvironment): String {
        val objectName = serviceEnvironment.name
            .replace('-', '_')
            .toUpperCase()
        val domain = serviceEnvironment.publicDomainName
        return """$objectName("$domain")"""
    }
}

data class ServiceEnvironment(val name: String, val region: String, val publicDomainName: String)

fun Path.resolve(vararg others: String): Path = others.fold(this) { acc, other -> acc.resolve(other) }

GenerateRegionCommand().main(args)